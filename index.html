<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="icebear's bolg">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="icebear's bolg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="icebear's bolg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> icebear's bolg </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">icebear's bolg</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/19/hello-world/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="wangnan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="icebear's bolg">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="icebear's bolg" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/19/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-19T14:42:50+08:00">
                2017-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/26/Canal学习笔记/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="wangnan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="icebear's bolg">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="icebear's bolg" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/26/Canal学习笔记/" itemprop="url">
                  Canal
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-26T18:09:15+08:00">
                2016-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1. 工作原理"></a>1. 工作原理</h1><p>mysql主备复制实现:</p>
<p><img src="http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y0djcTVDTTJJak16UUROM0F6TDRBek14QWpNdlFuYmwxR2FqRkdkMEYyTHQ5Mll1OEdkakZUTnVFelp0bDJMdm9EYzBSSGE.jpg" alt="mysql主备复制实现"></p>
<p>从上层来看，复制分成三步：</p>
<ul>
<li>master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）；</li>
<li>slave将master的binary log events拷贝到它的中继日志(relay log)；</li>
<li>slave重做中继日志中的事件，将改变反映它自己的数据。</li>
</ul>
<p>canal的工作原理：<br><img src="https://camo.githubusercontent.com/46c626b4cde399db43b2634a7911a04aecf273a0/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333130372f63383762363762612d333934632d333038362d393537372d3964623035626530346339352e6a7067" alt=""></p>
<p>原理相对比较简单：</p>
<ul>
<li>canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议</li>
<li>mysql master收到dump请求，开始推送binary log给slave(也就是canal)</li>
<li>canal解析binary log对象(原始为byte流)</li>
</ul>
<h1 id="2-架构"><a href="#2-架构" class="headerlink" title="2 架构"></a>2 架构</h1><p><img src="https://camo.githubusercontent.com/fad39e40f844ae4196035f4007e31ae2bd020616/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333132362f34393535303038352d306364322d333266612d383661362d6636373664623562353937622e6a7067" alt=""></p>
<p>说明：</p>
<ul>
<li>server代表一个canal运行实例，对应于一个jvm</li>
<li>instance对应于一个数据队列 （1个server对应1..n个instance)</li>
</ul>
<p>instance模块：</p>
<ul>
<li>eventParser (数据源接入，模拟slave协议和master进行交互，协议解析)</li>
<li>eventSink (Parser和Store链接器，进行数据过滤，加工，分发的工作)</li>
<li>eventStore (数据存储)</li>
<li>metaManager (增量订阅&amp;消费信息管理器)</li>
</ul>
<h1 id="3-知识科普"><a href="#3-知识科普" class="headerlink" title="3 知识科普"></a>3 知识科普</h1><p>mysql的Binlay Log介绍</p>
<ul>
<li><a href="http://dev.mysql.com/doc/refman/5.5/en/binary-log.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.5/en/binary-log.html</a></li>
<li><a href="http://www.taobaodba.com/html/474_mysqls-binary-log_details.html" target="_blank" rel="external">http://www.taobaodba.com/html/474_mysqls-binary-log_details.html</a></li>
</ul>
<p>简单点说：</p>
<ul>
<li>mysql的binlog是多文件存储，定位一个LogEvent需要通过binlog filename + binlog position，进行定位</li>
<li>mysql的binlog数据格式，按照生成的方式，主要分为：statement-based、row-based、mixed。</li>
</ul>
<pre><code>mysql&gt; show variables like &apos;binlog_format&apos;;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| binlog_format | ROW   |
+---------------+-------+
1 row in set (0.00 sec)
</code></pre><p>目前canal支持所有模式的增量订阅(但配合同步时，因为statement只有sql，没有数据，无法获取原始的变更日志，所以一般建议为ROW模式)</p>
<h1 id="4-EventParser设计"><a href="#4-EventParser设计" class="headerlink" title="4 EventParser设计"></a>4 EventParser设计</h1><p>大致过程：</p>
<p><img src="http://kaimingwan.com/canal/_image/binlog%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7canal%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%EF%BC%883\" alt="">%EF%BC%9Aparser%E5%92%8Cprotocol%E6%A8%A1%E5%9D%97/14-14-42.jpg)</p>
<p>整个parser过程大致可分为几步：</p>
<ol>
<li>Connection获取上一次解析成功的位置 (如果第一次启动，则获取初始指定的位置或者是当前数据库的binlog位点)</li>
<li>Connection建立链接，发送BINLOG_DUMP指令</li>
</ol>
<pre><code>// 0. write command number
// 1. write 4 bytes bin-log position to start at
// 2. write 2 bytes bin-log flags
// 3. write 4 bytes server id of the slave
// 4. write bin-log file name
</code></pre><ol>
<li>Mysql开始推送Binaly Log</li>
<li>接收到的Binaly Log的通过Binlog parser进行协议解析，补充一些特定信息<br>// 补充字段名字，字段类型，主键信息，unsigned类型处理</li>
<li>传递给EventSink模块进行数据存储，是一个阻塞操作，直到存储成功</li>
<li>存储成功后，定时记录Binaly Log位置</li>
</ol>
<p>mysql的Binlay Log网络协议：<br><img src="https://camo.githubusercontent.com/5bb9d62abfd7c35302de1a1e159a77d9d7395620/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333137332f36333861383361652d336235632d336638332d393732322d3263313931326537636163362e706e67" alt=""></p>
<p>说明：</p>
<ul>
<li>图中的协议4byte header，主要是描述整个binlog网络包的length</li>
<li>binlog event structure，详细信息请参考： <a href="http://forge.mysql.com/wiki/MySQL_Internals_Binary_Log" target="_blank" rel="external">http://forge.mysql.com/wiki/MySQL_Internals_Binary_Log</a></li>
</ul>
<h1 id="5-EventSink设计"><a href="#5-EventSink设计" class="headerlink" title="5 EventSink设计"></a>5 EventSink设计</h1><p><img src="https://camo.githubusercontent.com/77829ab83df80538641d75e074cdcd68752f4c89/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333231342f30613266643637312d643665392d336564372d623131302d3661336237333861336362302e6a7067" alt=""></p>
<p>说明：</p>
<ul>
<li>数据过滤：支持通配符的过滤模式，表名，字段内容等</li>
<li>数据路由/分发：解决1:n (1个parser对应多个store的模式)</li>
<li>数据归并：解决n:1 (多个parser对应1个store)</li>
<li>数据加工：在进入store之前进行额外的处理，比如join</li>
</ul>
<h5 id="数据1-n业务"><a href="#数据1-n业务" class="headerlink" title="数据1:n业务"></a>数据1:n业务</h5><p>为了合理的利用数据库资源， 一般常见的业务都是按照schema进行隔离，然后在mysql上层或者dao这一层面上，进行一个数据源路由，屏蔽数据库物理位置对开发的影响，阿里系主要是通过cobar/tddl来解决数据源路由问题。</p>
<p>所以，一般一个数据库实例上，会部署多个schema，每个schema会有由1个或者多个业务方关注</p>
<h5 id="数据n-1业务"><a href="#数据n-1业务" class="headerlink" title="数据n:1业务"></a>数据n:1业务</h5><p>同样，当一个业务的数据规模达到一定的量级后，必然会涉及到水平拆分和垂直拆分的问题，针对这些拆分的数据需要处理时，就需要链接多个store进行处理，消费的位点就会变成多份，而且数据消费的进度无法得到尽可能有序的保证。</p>
<p>所以，在一定业务场景下，需要将拆分后的增量数据进行归并处理，比如按照时间戳/全局id进行排序归并.</p>
<h1 id="6-EventStore设计"><a href="#6-EventStore设计" class="headerlink" title="6 EventStore设计"></a>6 EventStore设计</h1><ol>
<li>目前仅实现了Memory内存模式，后续计划增加本地file存储，mixed混合模式</li>
<li>借鉴了Disruptor的RingBuffer的实现思路</li>
</ol>
<p><img src="http://kaimingwan.com/canal/_image/binlog%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7canal%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%EF%BC%886%EF%BC%89%EF%BC%9Astore%E6%A8%A1%E5%9D%97/14-05-44.jpg" alt=""></p>
<p>定义了3个cursor</p>
<ul>
<li>Put : Sink模块进行数据存储的最后一次写入位置</li>
<li>Get : 数据订阅获取的最后一次提取位置</li>
<li>Ack : 数据消费成功的最后一次消费位置</li>
</ul>
<p>借鉴Disruptor的RingBuffer的实现，将RingBuffer拉直来看：<br><img src="https://camo.githubusercontent.com/8684b7499fe7d4e022b8d9ffac1768f811caed01/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333233392f34663538393132642d376338652d333764652d623762382d3130646432316161366332322e6a7067" alt=""></p>
<p>实现说明：</p>
<ul>
<li>Put/Get/Ack cursor用于递增，采用long型存储</li>
<li>buffer的get操作，通过取余或者与操作。(与操作： cusor &amp; (size - 1) , size需要为2的指数，效率比较高)</li>
</ul>
<h1 id="7-Instance设计"><a href="#7-Instance设计" class="headerlink" title="7 Instance设计"></a>7 Instance设计</h1><p><img src="https://camo.githubusercontent.com/a43b8352e880d0bb43c02b2fc1603095d11cb5dc/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333234372f35646531633961662d373739382d336434322d626334332d3563353464383263346462662e6a7067" alt=""></p>
<p>instance代表了一个实际运行的数据队列，包括了EventPaser,EventSink,EventStore等组件。</p>
<p>抽象了CanalInstanceGenerator，主要是考虑配置的管理方式：</p>
<ul>
<li>manager方式： 和你自己的内部web console/manager系统进行对接。(目前主要是公司内部使用)</li>
<li>spring方式：基于spring xml + properties进行定义，构建spring配置.</li>
</ul>
<h1 id="8-Server设计"><a href="#8-Server设计" class="headerlink" title="8 Server设计"></a>8 Server设计</h1><p><img src="https://camo.githubusercontent.com/930fe71532c25812966359ed35ee2371ec4664e8/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333235372f66346466333862612d353965322d333938652d623565622d3162626662656363303637362e6a7067" alt=""></p>
<p>server代表了一个canal的运行实例，为了方便组件化使用，特意抽象了Embeded(嵌入式) / Netty(网络访问)的两种实现</p>
<ul>
<li>Embeded : 对latency和可用性都有比较高的要求，自己又能hold住分布式的相关技术(比如failover)</li>
<li>Netty : 基于netty封装了一层网络协议，由canalserver保证其可用性，采用的pull模型，当然latency会稍微打点折扣，不过这个也视情况而定。(阿里系的notify和metaq，典型的push/pull模型，目前也逐步的在向pull模型靠拢，push在数据量大的时候会有一些问题)</li>
</ul>
<h1 id="9-增量订阅-消费设计"><a href="#9-增量订阅-消费设计" class="headerlink" title="9 增量订阅/消费设计"></a>9 增量订阅/消费设计</h1><p><img src="https://camo.githubusercontent.com/db1debcfa50f4ebea1f56a1fa0e18a4e960cafcc/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333239372f39643765643133652d366138362d333836642d393266342d3835323233386334373562662e6a7067" alt=""></p>
<p>具体的协议格式，可参见：<a href="https://github.com/alibaba/canal/blob/master/protocol/src/main/java/com/alibaba/otter/canal/protocol/CanalProtocol.proto" target="_blank" rel="external">CanalProtocol.proto</a></p>
<p>get/ack/rollback协议介绍：</p>
<ul>
<li>Message getWithoutAck(int batchSize)，允许指定batchSize，一次可以获取多条，每次返回的对象为Message，包含的内容为：<br>a. batch id 唯一标识<br>b. entries 具体的数据对象，对应的数据对象格式：<a href="https://github.com/alibaba/canal/blob/master/protocol/src/main/java/com/alibaba/otter/canal/protocol/EntryProtocol.proto" target="_blank" rel="external">EntryProtocol.proto</a></li>
<li>Message getWithoutAck(int batchSize, Long timeout, TimeUnit unit)，相比于getWithoutAck(int batchSize)，允许设定获取数据的timeout超时时间<br>a. 拿够batchSize条记录或者超过timeout时间<br>b. timeout=0，阻塞等到足够的batchSize</li>
<li>void rollback(long batchId)，顾命思议，回滚上次的get请求，重新获取数据。基于get获取的batchId进行提交，避免误操作</li>
<li>void ack(long batchId)，顾命思议，确认已经消费成功，通知server删除数据。基于get获取的batchId进行提交，避免误操作</li>
</ul>
<p>canal的get/ack/rollback协议和常规的jms协议有所不同，允许get/ack异步处理，比如可以连续调用get多次，后续异步按顺序提交ack/rollback，项目中称之为流式api.</p>
<p>流式api设计的好处：</p>
<ul>
<li>get/ack异步化，减少因ack带来的网络延迟和操作成本(99%的状态都是处于正常状态，异常的rollback属于个别情况，没必要为个别的case牺牲整个性能)</li>
<li>get获取数据后，业务消费存在瓶颈或者需要多进程/多线程消费时，可以不停的轮询get数据，不停的往后发送任务，提高并行化. (作者在实际业务中的一个case：业务数据消费需要跨中美网络，所以一次操作基本在200ms以上，为了减少延迟，所以需要实施并行化)</li>
</ul>
<p>流式api设计：</p>
<p><img src="https://camo.githubusercontent.com/533903f4925be003abe78b259e77fd829fc58c2b/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333330302f37663739383665352d643863362d336131372d383739362d3731313636653662633264632e6a7067" alt=""></p>
<ul>
<li>每次get操作都会在meta中产生一个mark，mark标记会递增，保证运行过程中mark的唯一性</li>
<li>每次的get操作，都会在上一次的mark操作记录的cursor继续往后取，如果mark不存在，则在last ack cursor继续往后取</li>
<li>进行ack时，需要按照mark的顺序进行数序ack，不能跳跃ack. ack会删除当前的mark标记，并将对应的mark位置更新为last ack cusor</li>
<li>一旦出现异常情况，客户端可发起rollback情况，重新置位：删除所有的mark, 清理get请求位置，下次请求会从last ack cursor继续往后取</li>
</ul>
<p>流式api带来的异步响应模型：<br><img src="https://camo.githubusercontent.com/99854985217eb95d4faa0eea00f8fe2631fe803a/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303039302f363437392f35323062313532392d366665612d333932372d393635362d3333363661316661333337622e6a7067" alt=""></p>
<h1 id="10-数据对象格式：EntryProtocol-proto"><a href="#10-数据对象格式：EntryProtocol-proto" class="headerlink" title="10 数据对象格式：EntryProtocol.proto"></a>10 数据对象格式：<a href="https://github.com/alibaba/canal/blob/master/protocol/src/main/java/com/alibaba/otter/canal/protocol/EntryProtocol.proto" target="_blank" rel="external">EntryProtocol.proto</a></h1><pre><code>Entry
    Header
        logfileName [binlog文件名]
        logfileOffset [binlog position]
        executeTime [binlog里记录变更发生的时间戳]
        schemaName [数据库实例]
        tableName [表名]
        eventType [insert/update/delete类型]
    entryType   [事务头BEGIN/事务尾END/数据ROWDATA]
    storeValue  [byte数据,可展开，对应的类型为RowChange]

RowChange
    isDdl       [是否是ddl变更操作，比如create table/drop table]
    sql     [具体的ddl sql]
    rowDatas    [具体insert/update/delete的变更数据，可为多条，1个binlog event事件可对应多条变更，比如批处理]
        beforeColumns [Column类型的数组]
        afterColumns [Column类型的数组]

Column 
    index       [column序号]
    sqlType     [jdbc type]
    name        [column name]
    isKey       [是否为主键]
    updated     [是否发生过变更]
    isNull      [值是否为null]
    value       [具体的内容，注意为文本]
</code></pre><p>说明：</p>
<ul>
<li>可以提供数据库变更前和变更后的字段内容，针对binlog中没有的name,isKey等信息进行补全</li>
<li>可以提供ddl的变更语句</li>
</ul>
<h1 id="11-HA机制设计"><a href="#11-HA机制设计" class="headerlink" title="11 HA机制设计"></a>11 HA机制设计</h1><p>canal的ha分为两部分，canal server和canal client分别有对应的ha实现</p>
<ul>
<li>canal server: 为了减少对mysql dump的请求，不同server上的instance要求同一时间只能有一个处于running，其他的处于standby状态.</li>
<li>canal client: 为了保证有序性，一份instance同一时间只能由一个canal client进行get/ack/rollback操作，否则客户端接收无法保证有序。</li>
</ul>
<p>整个HA机制的控制主要是依赖了zookeeper的几个特性，watcher和EPHEMERAL节点(和session生命周期绑定)。</p>
<p>Canal Server:<br><img src="https://camo.githubusercontent.com/c8f1d98268a307821273e94e7eefcd29a26f9b78/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038302f333330332f64333230326332362d653935342d333563302d613331392d3537363034313032633537642e6a7067" alt=""></p>
<p>大致步骤：</p>
<ol>
<li>canal server要启动某个canal instance时都先向zookeeper进行一次尝试启动判断 (实现：创建EPHEMERAL节点，谁创建成功就允许谁启动)</li>
<li>创建zookeeper节点成功后，对应的canal server就启动对应的canal instance，没有创建成功的canal instance就会处于standby状态</li>
<li>一旦zookeeper发现canal server A创建的节点消失后，立即通知其他的canal server再次进行步骤1的操作，重新选出一个canal server启动instance.</li>
<li>canal client每次进行connect时，会首先向zookeeper询问当前是谁启动了canal instance，然后和其建立链接，一旦链接不可用，会重新尝试connect.’</li>
</ol>
<p>Canal Client的方式和canal server方式类似，也是利用zookeeper的抢占EPHEMERAL节点的方式进行控制.</p>
<h1 id="12-mysql的配置"><a href="#12-mysql的配置" class="headerlink" title="12 mysql的配置"></a>12 mysql的配置</h1><p>a. canal的原理是基于mysql binlog技术，所以这里一定需要开启mysql的binlog写入功能，建议配置binlog模式为row.</p>
<pre><code>[mysqld]
log-bin=mysql-bin #添加这一行开启binlog
binlog-format=ROW #选择row模式
server_id=1 #配置mysql replaction需要定义，不能和canal的slaveId重复
</code></pre><p>b. canal的原理是模拟自己为mysql slave，所以这里一定需要做为mysql slave的相关权限.</p>
<pre><code>CREATE USER canal IDENTIFIED BY &apos;canal&apos;;  
GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;canal&apos;@&apos;%&apos;;
-- GRANT ALL PRIVILEGES ON *.* TO &apos;canal&apos;@&apos;%&apos; ;
FLUSH PRIVILEGES;
</code></pre><p>针对已有的账户可通过grant</p>
<h1 id="canal-配置"><a href="#canal-配置" class="headerlink" title="canal 配置"></a>canal 配置</h1><p>介绍配置之前，先了解下canal的配置加载方式：</p>
<p><img src="https://camo.githubusercontent.com/3772f5e12fb46df1032685319c83c557b3f6a098/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038312f383735392f34666161376332652d656439352d333633382d613365322d3862343831633865343036302e6a7067" alt=""></p>
<p>canal配置方式有两种：</p>
<ul>
<li>ManagerCanalInstanceGenerator：基于manager管理的配置方式，目前alibaba内部配置使用这种方式。大家可以实现CanalConfigClient，连接各自的管理系统，即可完成接入。</li>
<li>SpringCanalInstanceGenerator：基于本地spring xml的配置方式，目前开源版本已经自带该功能所有代码，建议使用</li>
</ul>
<h3 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h3><p>spring配置的原理是将整个配置抽象为两部分：</p>
<ul>
<li>xxxx-instance.xml (canal组件的配置定义，可以在多个instance配置中共享)</li>
<li>xxxx.properties (每个instance通道都有各自一份定义，因为每个mysql的ip，帐号，密码等信息不会相同)</li>
</ul>
<p>通过spring的PropertyPlaceholderConfigurer通过机制将其融合，生成一份instance实例对象，每个instance对应的组件都是相互独立的，互不影响</p>
<h3 id="properties配置文件"><a href="#properties配置文件" class="headerlink" title="properties配置文件"></a>properties配置文件</h3><p>properties配置分为两部分：</p>
<ul>
<li>canal.properties (系统根配置文件)</li>
<li>instance.properties (instance级别的配置文件，每个instance一份)</li>
</ul>
<h3 id="canal-properties介绍："><a href="#canal-properties介绍：" class="headerlink" title="canal.properties介绍："></a>canal.properties介绍：</h3><p>canal配置主要分为两部分定义：</p>
<ol>
<li>instance列表定义 (列出当前server上有多少个instance，每个instance的加载方式是spring/manager等)</li>
</ol>
<table>
<thead>
<tr>
<th>参数名字</th>
<th>参数说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>canal.destinations</td>
<td>当前server上部署的instance列表</td>
<td>无</td>
</tr>
<tr>
<td>canal.conf.dir</td>
<td>conf/目录所在的路径</td>
<td>../conf</td>
</tr>
<tr>
<td>canal.auto.scan</td>
<td>开启instance自动扫描，canal.conf.dir目录下的instance配置变化会自动触发处理</td>
<td>true</td>
</tr>
<tr>
<td>canal.auto.scan.interval</td>
<td>instance自动扫描的间隔时间，单位秒</td>
<td>5</td>
</tr>
<tr>
<td>canal.instance.global.mode</td>
<td>全局配置加载方式</td>
<td>spring</td>
</tr>
<tr>
<td>canal.instance.global.lazy</td>
<td>全局lazy模式</td>
<td>false</td>
</tr>
<tr>
<td>canal.instance.global.manager.address</td>
<td>全局的manager配置方式的链接信息</td>
<td>无</td>
</tr>
<tr>
<td>canal.instance.global.spring.xml</td>
<td>全局的spring配置方式的组件文件</td>
<td>classpath: spring/file-instance.xml </td>
</tr>
<tr>
<td>canal.instance.example.mode, canal.instance.example.lazy, canal.instance.example.spring.xml</td>
<td>instance级别的配置定义，如有配置，会自动覆盖全局配置定义模式。命名规则：canal.instance.{name}.xxx</td>
<td>无</td>
</tr>
</tbody>
</table>
<ol>
<li>common参数定义，比如可以将instance.properties的公用参数，抽取放置到这里，这样每个instance启动的时候就可以共享. 【instance.properties配置定义优先级高于canal.properties】</li>
</ol>
<table>
<thead>
<tr>
<th>参数名字</th>
<th>参数说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>canal.id</td>
<td>每个canal server实例的唯一标识，暂无实际意义</td>
<td>1</td>
</tr>
<tr>
<td>canal.ip</td>
<td>canal server绑定的本地IP信息，如果不配置，默认选择一个本机IP进行启动服务</td>
<td>无</td>
</tr>
<tr>
<td>canal.port</td>
<td>canal server提供socket服务的端口</td>
<td>11111</td>
</tr>
<tr>
<td>canal.zkServers</td>
<td>canal server链接zookeeper集群的链接信息 例子：127.0.0.1:2181,127.0.0.1:2182</td>
<td>无</td>
</tr>
<tr>
<td>canal.zookeeper.flush.period</td>
<td>canal持久化数据到zookeeper上的更新频率，单位毫秒</td>
<td>1000</td>
</tr>
<tr>
<td>canal.file.data.dir    canal</td>
<td>持久化数据到file上的目录</td>
<td>../conf</td>
</tr>
<tr>
<td>canal.file.flush.period    canal</td>
<td>持久化数据到file上的更新频率，单位毫秒</td>
<td>1000</td>
</tr>
<tr>
<td>canal.instance.memory.batch.mode</td>
<td>canal内存store中数据缓存模式。ITEMSIZE :根据buffer.size进行限制，只限制记录的数量; MEMSIZE: 根据buffer.size * buffer.memunit的大小，限制缓存记录的大小</td>
<td>MEMSIZE</td>
</tr>
<tr>
<td>canal.instance.memory.buffer.size</td>
<td>canal内存store中可缓存buffer记录数，需要为2的指数</td>
<td>16384</td>
</tr>
<tr>
<td>canal.instance.memory.buffer.memunit</td>
<td>内存记录的单位大小，默认1KB，和buffer.size组合决定最终的内存使用大小</td>
<td>1024</td>
</tr>
<tr>
<td>canal.instance.transactionn.size</td>
<td>最大事务完整解析的长度支持。超过该长度后，一个事务可能会被拆分成多次提交到canal store中，无法保证事务的完整可见性</td>
<td>1024</td>
</tr>
<tr>
<td>canal.instance.fallbackIntervalInSeconds</td>
<td>canal发生mysql切换时，在新的mysql库上查找binlog时需要往前查找的时间，单位秒（说明：mysql主备库可能存在解析延迟或者时钟不统一，需要回退一段时间，保证数据不丢）</td>
<td>60</td>
</tr>
<tr>
<td>canal.instance.detecting.enable</td>
<td>是否开启心跳检查</td>
<td>false</td>
</tr>
<tr>
<td>canal.instance.detecting.sql</td>
<td>心跳检查sql</td>
<td>insert into retl.xdual values(1,now()) on duplicate key update x=now()</td>
</tr>
<tr>
<td>canal.instance.detecting.interval.time</td>
<td>心跳检查频率，单位秒</td>
<td>3</td>
</tr>
<tr>
<td>canal.instance.detecting.retry.threshold</td>
<td>心跳检查失败重试次数</td>
<td>3</td>
</tr>
<tr>
<td>canal.instance.detecting.heartbeatHaEnable</td>
<td>心跳检查失败后，是否开启自动mysql自动切换（说明：比如心跳检查失败超过阀值后，如果该配置为true，canal就会自动链到mysql备库获取binlog数据）</td>
<td>false</td>
</tr>
<tr>
<td>canal.instance.network.receiveBufferSize</td>
<td>网络链接参数，SocketOptions.SO_RCVBUF</td>
<td>16384</td>
</tr>
<tr>
<td>canal.instance.network.sendBufferSize</td>
<td>网络链接参数，SocketOptions.SO_SNDBUF</td>
<td>16384</td>
</tr>
<tr>
<td>canal.instance.network.soTimeout</td>
<td>网络链接参数，SocketOptions.SO_TIMEOUT</td>
<td>30</td>
</tr>
<tr>
<td>canal.instance.filter.query.dcl</td>
<td>是否忽略DCL的query语句，比如grant/create user等</td>
<td>false</td>
</tr>
<tr>
<td>canal.instance.filter.query.dml</td>
<td>是否忽略DML的query语句，比如insert/update/delete table</td>
<td>false</td>
</tr>
<tr>
<td>canal.instance.filter.query.ddl</td>
<td>是否忽略DDL的query语句，比如create table/alater table/drop table/rename table/create index/drop index. (目前支持的ddl类型主要为table级别的操作，create databases/trigger/procedure暂时划分为dcl类型)</td>
<td>false</td>
</tr>
<tr>
<td>canal.instance.get.ddl.isolation</td>
<td>ddl语句是否隔离发送，开启隔离可保证每次只返回发送一条ddl数据，不和其他dml语句混合返回.(otter ddl同步使用)</td>
<td>false</td>
</tr>
</tbody>
</table>
<h3 id="instance-properties介绍："><a href="#instance-properties介绍：" class="headerlink" title="instance.properties介绍："></a>instance.properties介绍：</h3><p>在canal.properties定义了canal.destinations后，需要在canal.conf.dir对应的目录下建立同名的文件</p>
<p>比如：</p>
<pre><code>canal.destinations = example1,example2
这时需要创建example1和example2两个目录，每个目录里各自有一份instance.properties.
ps. canal自带了一份instance.properties demo，可直接复制conf/example目录进行配置修改

cp -R example example1/
cp -R example example2/
</code></pre><p>instance.properties参数列表：</p>
<table>
<thead>
<tr>
<th>参数名字</th>
<th>参数说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>canal.instance.mysql.slaveId</td>
<td>mysql集群配置中的serverId概念，需要保证和当前mysql集群中id唯一</td>
<td>1234</td>
</tr>
<tr>
<td>canal.instance.master.address</td>
<td>mysql主库链接地址</td>
<td>127.0.0.1:3306</td>
</tr>
<tr>
<td>canal.instance.master.journal.name</td>
<td>mysql主库链接时起始的binlog文件</td>
<td>无</td>
</tr>
<tr>
<td>canal.instance.master.position</td>
<td>mysql主库链接时起始的binlog偏移量</td>
<td>无</td>
</tr>
<tr>
<td>canal.instance.master.timestamp</td>
<td>mysql主库链接时起始的binlog的时间戳</td>
<td>无</td>
</tr>
<tr>
<td>canal.instance.dbUsername</td>
<td>mysql数据库帐号</td>
<td>canal</td>
</tr>
<tr>
<td>canal.instance.dbPassword</td>
<td>mysql数据库密码</td>
<td>canal</td>
</tr>
<tr>
<td>canal.instance.defaultDatabaseName</td>
<td>mysql链接时默认schema</td>
<td></td>
</tr>
<tr>
<td>canal.instance.connectionCharset</td>
<td>mysql 数据解析编码</td>
<td>UTF-8</td>
</tr>
<tr>
<td>canal.instance.filter.regex    mysql</td>
<td>数据解析关注的表，Perl正则表达式.</td>
<td>.<em>\..</em></td>
</tr>
</tbody>
</table>
<p>几点说明：</p>
<ol>
<li>mysql链接时的起始位置</li>
</ol>
<ul>
<li>canal.instance.master.journal.name + canal.instance.master.position : 精确指定一个binlog位点，进行启动</li>
<li>canal.instance.master.timestamp : 指定一个时间戳，canal会自动遍历mysql binlog，找到对应时间戳的binlog位点后，进行启动</li>
<li>不指定任何信息：默认从当前数据库的位点，进行启动。(show master status)</li>
</ul>
<ol>
<li>mysql解析关注表定义 标准的Perl正则，注意转义时需要双斜杠：\</li>
<li>mysql链接的编码 目前canal版本仅支持一个数据库只有一种编码，如果一个库存在多个编码，需要通过filter.regex配置，将其拆分为多个canal instance，为每个instance指定不同的编码</li>
</ol>
<h3 id="instance-xml配置文件"><a href="#instance-xml配置文件" class="headerlink" title="instance.xml配置文件"></a>instance.xml配置文件</h3><p>目前默认支持的instance.xml有以下几种：</p>
<pre><code>spring/memory-instance.xml
spring/file-instance.xml
spring/default-instance.xml
spring/group-instance.xml
</code></pre><p>在介绍instance配置之前，先了解一下canal如何维护一份增量订阅&amp;消费的关系信息：</p>
<ul>
<li>解析位点 (parse模块会记录，上一次解析binlog到了什么位置，对应组件为：CanalLogPositionManager)</li>
<li>消费位点 (canal server在接收了客户端的ack后，就会记录客户端提交的最后位点，对应的组件为：CanalMetaManager)</li>
</ul>
<p>对应的两个位点组件，目前都有几种实现：</p>
<ul>
<li>memory (memory-instance.xml中使用)</li>
<li>zookeeper</li>
<li>mixed</li>
<li>file (file-instance.xml中使用，集合了file+memory模式，先写内存，定时刷新数据到本地file上)</li>
<li>period (default-instance.xml中使用，集合了zookeeper+memory模式，先写内存，定时刷新数据到zookeeper上)</li>
</ul>
<hr>
<p><strong>memory-instance.xml介绍：</strong></p>
<p>所有的组件(parser , sink , store)都选择了内存版模式，记录位点的都选择了memory模式，重启后又会回到初始位点进行解析</p>
<p>特点：速度最快，依赖最少(不需要zookeeper)</p>
<p>场景：一般应用在quickstart，或者是出现问题后，进行数据分析的场景，不应该将其应用于生产环境</p>
<p><strong>file-instance.xml介绍：</strong></p>
<p>所有的组件(parser , sink , store)都选择了基于file持久化模式，注意，不支持HA机制.</p>
<p>特点：支持单机持久化</p>
<p>场景：生产环境，无HA需求，简单可用.</p>
<p><strong>default-instance.xml介绍：</strong></p>
<p>所有的组件(parser , sink , store)都选择了持久化模式，目前持久化的方式主要是写入zookeeper，保证数据集群共享.</p>
<p>特点：支持HA</p>
<p>场景：生产环境，集群化部署.</p>
<p><strong>group-instance.xml介绍：</strong></p>
<p>主要针对需要进行多库合并时，可以将多个物理instance合并为一个逻辑instance，提供客户端访问。</p>
<p>场景：分库业务。 比如产品数据拆分了4个库，每个库会有一个instance，如果不用group，业务上要消费数据时，需要启动4个客户端，分别链接4个instance实例。使用group后，可以在canal server上合并为一个逻辑instance，只需要启动1个客户端，链接这个逻辑instance即可.</p>
<p><strong>instance.xml设计初衷：</strong></p>
<p>允许进行自定义扩展，比如实现了基于数据库的位点管理后，可以自定义一份自己的instance.xml，整个canal设计中最大的灵活性在于此</p>
<h1 id="13-ClientAPI"><a href="#13-ClientAPI" class="headerlink" title="13 ClientAPI"></a>13 ClientAPI</h1><p>在了解具体API之前，需要提前了解下canal client的类设计，这样才可以正确的使用好canal.</p>
<p><img src="https://camo.githubusercontent.com/8cc684cf92e22d738d57b002c356afba96bcc4f5/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303039302f363435332f39326233343335302d323566632d333162332d626361362d3865326131653763356532322e6a7067" alt=""></p>
<p>大致分为几部分：</p>
<ul>
<li>ClientIdentity: canal client和server交互之间的身份标识，目前clientId写死为1001. (目前canal server上的一个instance只能有一个client消费，clientId的设计是为1个instance多client消费模式而预留的，暂时不需要理会)</li>
<li>CanalConnector: SimpleCanalConnector/ClusterCanalConnector两种connector的实现，simple针对的是简单的ip直连模式，cluster针对多ip的模式，可依赖CanalNodeAccessStrategy进行failover控制</li>
<li>CanalNodeAccessStrategy: SimpleNodeAccessStrategy/ClusterNodeAccessStrategy两种failover的实现，simple针对给定的初始ip列表进行failover选择，cluster基于zookeeper上的cluster节点动态选择正在运行的canal server.</li>
<li>ClientRunningMonitor/ClientRunningListener/ClientRunningData: client running相关控制，主要为解决client自身的failover机制。canal client允许同时启动多个canal client，通过running机制，可保证只有一个client在工作，其他client做为冷备. 当运行中的client挂了，running会控制让冷备中的client转为工作模式，这样就可以确保canal client也不会是单点. 保证整个系统的高可用性.</li>
</ul>
<h1 id="14-代码框架-类图设计"><a href="#14-代码框架-类图设计" class="headerlink" title="14 代码框架 类图设计"></a>14 代码框架 类图设计</h1><p><strong>整体类图设计</strong></p>
<p><img src="https://camo.githubusercontent.com/a9b2f3b6a6a6b08d315ca1d50edf54da825b88b1/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038322f353139322f35306635326161322d643838362d333366322d613661362d3639343631316438363962612e6a7067" alt=""></p>
<p>说明：</p>
<ul>
<li>CanalLifeCycle为所有canal模块的生命周期接口</li>
<li>CanalInstance组合parser,sink,store三个子模块，三个子模块的生命周期统一受CanalInstance管理</li>
<li>CanalServer聚合了多个CanalInstance</li>
</ul>
<p><strong>EventParser类图设计和扩展</strong></p>
<p><img src="https://camo.githubusercontent.com/18166478784e086d703bb7121a2d8f7e93127243/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038322f353139362f36376439326533362d366162302d333362362d386363662d3565663362373539303564302e6a7067" alt=""></p>
<p>每个EventParser都会关联两个内部组件： CanalLogPositionManager ， CanalHAController</p>
<ul>
<li>CanalLogPositionManager : 记录binlog最后一次解析成功位置信息，主要是描述下一次canal启动的位点</li>
<li>CanalHAController：控制EventParser的链接主机管理，判断当前该链接哪个mysql数据库.</li>
</ul>
<p>说明：</p>
<ol>
<li>目前开源版本只有支持mysql的协议(LocalBinlog就是类似于relay log的那种模式，直接根据relay log进行数据消费)</li>
<li>内部版本会有OracleEventParser，获取oracle增量变更信息，因为涉及一些政治，商业和产品关系，没有随canal开源。(oracle增量解析目前为c语言开发，提供socket方式供canal接入)</li>
</ol>
<p><strong>CanalLogPositionManager类图设计</strong></p>
<p><img src="https://camo.githubusercontent.com/9e1bf18f449a20c5183234b45bee33fdcdce9fb0/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038322f353230322f63303331646238302d636564302d333634662d626430312d6636613162356436333462652e6a7067" alt=""></p>
<p>说明：</p>
<ol>
<li>如果CanalEventStore选择的是内存模式，可不保留解析位置，下一次canal启动时直接依赖CanalMetaManager记录的最后一次消费成功的位点即可. (最后一次ack提交的数据位点)</li>
<li>如果CanalEventStore选择的是持久化模式，可通过zookeeper记录位点信息，canal instance发生failover切换到另一台机器，可通过读取zookeeper获取位点信息.</li>
</ol>
<p>通过实现自己的CanalLogPositionManager，比如记录位点信息到本地文件/nas文件，简单可用的无HA的模式.</p>
<p><strong>CanalHAController类图设计</strong></p>
<p><img src="https://camo.githubusercontent.com/de18dd87ba5f6a5c26b59bb9c18fefda78255440/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038322f353232342f35633065336639372d306265392d333761342d626563662d6136373336623333316435622e6a7067" alt=""></p>
<p>说明：</p>
<ol>
<li>常见的就是基于心跳语句，定时请求当前链接的数据库，超过一定次数检测失败时，尝试切换到备机.</li>
<li>比如阿里内部会有一套数据库主备信息管理系统，DBA做了数据库主备切换或者机器下线，推送配置到各个应用节点，HAController收到后，控制EventParser进行链接切换.</li>
</ol>
<p><strong>EventSink类图设计和扩展</strong></p>
<p><img src="https://camo.githubusercontent.com/593a6e8c7c0e9fd0ae1fc1edf1da32d1ffb02315/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038322f353234302f35643637363930382d343261372d333966322d616333372d6537653366666538653931372e6a7067" alt=""></p>
<p><strong>EventStore类图设计和扩展</strong></p>
<p><img src="https://camo.githubusercontent.com/74a5c58b7f6eecad6e965fa466d2d71e1a72b1ba/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038322f353234342f30376161343038392d393962312d333731642d613438632d6433633562666330616365622e6a7067" alt=""></p>
<p>说明：</p>
<ol>
<li>抽象了CanalStoreScavenge ， 解决数据的清理，比如定时清理，满了之后清理，每次ack清理等</li>
<li>CanalEventStore接口，主要包含put/get/ack/rollback的相关接口. put/get操作会组成一个生产者/消费者模式，每个store都会有存储大小设计，存储满了，put操作会阻塞等待get获取数据，所以不会无线占用存储，比如内存大小</li>
</ol>
<pre><code>a. 目前EventStore主要实现了memory模式，支持按照内存大小和内存记录数进行存储大小限制.
b. 后续可开发基于本地文件的存储模式
c. 基于文件存储和内存存储，开发mixed模式，做成两级队列，内存buffer有空位时，将文件的数据读入到内存buffer中。
</code></pre><p><em>重要：实现基于mixed模式后，canal才可以说是完成真正的消费/订阅的模型 (取1份binlog数据，提供多个客户端消费，消费有快有慢，各自保留消费位点)</em></p>
<p><strong>MetaManager类图设计和扩展</strong></p>
<p><img src="https://camo.githubusercontent.com/320b9df34570fef32419b9034c768ff661f624d5/687474703a2f2f646c2e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038322f353235352f35333134623836352d666437392d333834652d623737302d6339613232653433366335322e6a7067" alt=""></p>
<p>说明：metaManager目前同样支持了多种模式，最顶层的就是memory和zookeeper的模式，还有就是mixed模式，先写内存，再写zookeeper.通过实现自己的CanalMetaManager，比如记录位点信息到本地文件/nas文件，简单可用的无HA的模式.</p>
<p><strong>应用扩展 （Advanced Topic）</strong><br>上面介绍了相关模块的设计，这里介绍下如何将自己的扩展代码应用到canal中. <a href="https://github.com/alibaba/canal/wiki/DevGuide#%E5%BA%94%E7%94%A8%E6%89%A9%E5%B1%95" target="_blank" rel="external">https://github.com/alibaba/canal/wiki/DevGuide#%E5%BA%94%E7%94%A8%E6%89%A9%E5%B1%95</a></p>
<h1 id="15-Canal源码分析"><a href="#15-Canal源码分析" class="headerlink" title="15 Canal源码分析"></a>15 Canal源码分析</h1><p>见博客链接： <a href="http://kaimingwan.com/tag/canal" target="_blank" rel="external">http://kaimingwan.com/tag/canal</a></p>
<h1 id="16-Producer增量异常问题定位思路"><a href="#16-Producer增量异常问题定位思路" class="headerlink" title="16 Producer增量异常问题定位思路"></a>16 Producer增量异常问题定位思路</h1><p>按照上述的分析，增量异常通常有以下三种情况：</p>
<ul>
<li>mysql没有记录binlog：检查mysql的配置，更新数据后观察binlog的position是否增加</li>
</ul>
<pre><code>show variables like &apos;log_bin%&apos;; 
show master status;
show binlog events  in &apos;mysql-bin.000047&apos;;
</code></pre><ul>
<li>canal异常，没有去读取：观察canal.log和shops.log是否有异常日志；截取javacore观察canal的主要线程是否正常；</li>
<li>producer的client没有发送getWithoutAck请求：观察producer的日志是否发送get请求</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="wangnan" />
          <p class="site-author-name" itemprop="name">wangnan</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangnan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>
